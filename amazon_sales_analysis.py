# -*- coding: utf-8 -*-
"""Amazon_Sales_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ti_so1XCU7qAfbr9e1dVnxZKhUusHDcs
"""

import pandas as pd
import sqlite3

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install ipython-sql --quiet
# %load_ext sql

#Reading the data
df=pd.read_excel('/content/Amazon Sale Report.xlsx')

#Discovering the data
df.head()

df.shape

# Checking data types and format
df.info()

df.info()

#drop New and PendingS columns as they are empty
df.drop(columns=['New', 'PendingS'], inplace=True)
df.columns

#Looking for duplicated rows
df.duplicated().sum()

#Droping the duplicated row
df.drop_duplicates(inplace=True)

df.shape

#Converting the columns names to snake format
def clean_column_names(columns):
    return columns.str.strip().str.lower().str.replace(r'[^\w\s]', '_', regex=True).str.replace(r'\s+', '_', regex=True)

df_cleaned = df.copy()
df_cleaned.columns = clean_column_names(df_cleaned.columns)
df_cleaned

# Connect to SQLite and create a database
conn = sqlite3.connect("amazon_sales.db")  # This creates 'amazon_sales.db'

# Write the data to a table in SQLite
df_cleaned.to_sql("amazon_sales", conn, if_exists="replace", index=False)

print("Database and table created successfully!")

# Commented out IPython magic to ensure Python compatibility.
# %sql sqlite:///amazon_sales.db

# Commented out IPython magic to ensure Python compatibility.
# %config SqlMagic.style = '_DEPRECATED_DEFAULT'

# Mathematical checks where necessary (sum, min, max)
df_cleaned.describe()

df_cleaned

#Now, we are going to see the distinct values in each column

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct Status from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct Fulfilment  from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct sales_channel from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct "ship_service_level" from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct "category" from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct "size" from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select distinct "courier_status" from amazon_sales

# Commented out IPython magic to ensure Python compatibility.
# #Identifying zero/blank/null values
# %%sql
# SELECT count(*)
# FROM amazon_sales
# WHERE (amount IS NULL OR amount = 0)
#   AND (status <> "Cancelled" OR courier_status <> "Unshipped");

# Commented out IPython magic to ensure Python compatibility.
# # Removing null and zero values from amount where the status is canceled or unshipped
# %%sql
# UPDATE amazon_sales
# SET amount = (
#              SELECT AVG(amount)
#              FROM amazon_sales
#              WHERE NOT ((amount IS NULL OR amount = 0)
#              AND (status <> "Cancelled" OR courier_status <> "Unshipped")))
#   where ((amount IS NULL OR amount = 0)
#   AND (status <> "Cancelled" OR courier_status <> "Unshipped"));

# Commented out IPython magic to ensure Python compatibility.
# #Count the null values in city, state, postalcode, and country
# %%sql
# SELECT COUNT(*)
# FROM amazon_sales
# WHERE ship_city IS NULL
#   AND ship_state IS NULL
#   AND ship_postal_code IS NULL
#   AND ship_country IS NULL;

# Commented out IPython magic to ensure Python compatibility.
# #Droping the rows with null values in city, state, postalcode, and country
# %%sql
# Delete from amazon_sales
# WHERE ship_city IS NULL
#   AND ship_state IS NULL
#   AND ship_postal_code IS NULL
#   AND ship_country IS NULL;

# Commented out IPython magic to ensure Python compatibility.
# #Counting the nulls in currency
# %%sql
# select count(*) from amazon_sales where "currency" is null

# Commented out IPython magic to ensure Python compatibility.
# #Filling out the nulls in currency column with "INR"
# %%sql
# Update amazon_sales set "currency" = "INR" where "currency" is null

# Commented out IPython magic to ensure Python compatibility.
# #Counting the nulls in fulfilled by column
# %%sql
# select count(*) from amazon_sales where "fulfilled_by" is null

# Commented out IPython magic to ensure Python compatibility.
# #Filling out the nulls in fulfilled by coulmn with "others" value
# %%sql
# Update amazon_sales set "fulfilled_by" = "others" where "fulfilled_by" is null

# Commented out IPython magic to ensure Python compatibility.
# #ignore this ya razan
# %%sql
# 
# Select count(*) from (
# select order_id, count(*)
# from amazon_sales
# Group by order_id
# having count(*)>1);
#

# Commented out IPython magic to ensure Python compatibility.
# #counting the number of dupliactes in the order_ids
# %%sql
# Select sum(count) from (
# select order_id, count(*) as count
# from amazon_sales
# Group by order_id
# having count(*)>1) ;

# Commented out IPython magic to ensure Python compatibility.
# #droping the rows with duplicated order ids, not keeping the original one, as we dont know the original one
# %%sql
# DELETE FROM amazon_sales
# WHERE order_id IN (
#     SELECT order_id
#     FROM (
#         SELECT order_id
#         FROM amazon_sales
#         GROUP BY order_id
#         HAVING COUNT(*) > 1
#     ) AS duplicate_orders
# );

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# select count (*) from(
#   select distinct order_id from amazon_sales)

# Commented out IPython magic to ensure Python compatibility.
# #Counting the rows with zero quantity
# %%sql
# select count(*) from amazon_sales where qty = 0;

# Commented out IPython magic to ensure Python compatibility.
# #Deleting the rows with zero qty
# %%sql
# Delete from amazon_sales where qty = 0;

# now it is the time to use the cleaned dataset for some fun
query = "SELECT * FROM amazon_sales"
df_cleaned = pd.read_sql_query(query, conn)

df_cleaned.shape

#Creating a scatter plot for the amountto see if there is outliers
import matplotlib.pyplot as plt
df_cleaned.plot.scatter(x='amount', y='amount', color='blue', alpha=0.6, figsize=(8, 6))
plt.title("Amount")
plt.xlabel("Amount")
plt.ylabel("Amount")
plt.grid()
plt.show()

#it seems we have a one outlier abouve the 4000, so we want to include the values that are equal or less than 4000 in our analysis
df_cleaned = df_cleaned.query('amount <= 4000')

#Now we are ready to start our analysis

df_cleaned.info()

#We have to change the type of date column to datetime after doing all the cleaning as sql database save the date column as object
df_cleaned['date'] = pd.to_datetime(df_cleaned['date'])

#we want to start with knowing the most month that have the highest records
df_cleaned['month'] = df_cleaned['date'].dt.to_period('M')
orders_count = df_cleaned.groupby('month').size()
orders_count

plt.figure(figsize=(10,6))
orders_count.plot(kind='bar', color='#D5AAFF')
plt.title('Number of Orders by Month')
plt.xlabel('Month')
plt.ylabel('Orders')

# Plotting the total amount per month
amount_by_month = df_cleaned.groupby('month')['amount'].sum()
amount=amount_by_month.round().astype(int)
plt.figure(figsize=(10, 6))
amount.plot(kind='bar', color='#F6A1A1')
plt.title('Total Amount Per Month')
plt.xlabel('Month')
plt.ylabel('Amount')
from matplotlib.ticker import FuncFormatter
formatter = FuncFormatter(lambda x, _: f'{int(x):,}')
plt.gca().yaxis.set_major_formatter(formatter)

# Plotting the total orders per day
qty_by_day = df_cleaned.groupby('date')['qty'].sum()
plt.figure(figsize=(10, 6))
qty_by_day.plot(kind='line', color='orange')
plt.title('Total Orders by day')
plt.xlabel('Day')
plt.ylabel('Orders')
plt.grid()

# Plotting the number of orders for each status
status= df_cleaned.groupby('status').size()
plt.figure(figsize=(10, 6))
status.plot(kind='bar', color='red')
plt.title('Total orders per status')
plt.xlabel('Month')
plt.ylabel('Orders')

# Plotting the orders per category
category= df_cleaned.groupby('category').size()
plt.figure(figsize=(10, 6))
category.plot(kind='bar', color='#D7A1B2')
plt.title('Total orders per category')
plt.xlabel('Category')
plt.ylabel('Orders')

# Plotting the total orders per size
size= df_cleaned.groupby('size').size()
size = size.sort_values(ascending=False)
plt.figure(figsize=(10, 6))
size.plot(kind='bar', color='#228B22')
plt.title('Total Orders Per Size')
plt.xlabel('Size')
plt.ylabel('Orders')

# Plotting the shipping service level
servicelevel= df_cleaned.groupby('ship_service_level').size()
plt.figure(figsize=(10, 6))
colors= colors = ['#483D8B', '#E5D0FF']
servicelevel.plot(kind='pie', colors=colors, autopct='%1.1f%%', startangle=90)
plt.title('Ship Service Level')

# Plotting the orders per category (or orders count) in ascending order
category= df_cleaned.groupby('category').size()
plt.figure(figsize=(10, 6))
category= category.sort_values(ascending=False)
category.plot(kind='bar', color='#D7A1B2')
plt.title('Total orders per category')
plt.xlabel('Category')
plt.ylabel('Orders')

# Plotting the orders per status in ascending order
status= df_cleaned.groupby('status').size()
plt.figure(figsize=(10, 6))
status = status.sort_values(ascending=False)
status.plot(kind='bar', color='#483D8B')
plt.title('Total orders per Status')
plt.xlabel('Status')
plt.ylabel('Orders')

# Plotting the orders per city (top 10 cities)
city= df_cleaned.groupby('ship_city').size()
plt.figure(figsize=(10, 6))
city = city.sort_values(ascending=False).head(10)
city.plot(kind='bar', color='#483D6B')
plt.title('Total Orders Per Ship City')
plt.xlabel('Ship City')
plt.ylabel('Orders')

#Saving the cleaned dataset for dashboard visualization
df_cleaned.to_excel("cleaned_amazonData.xlsx", index=False)

